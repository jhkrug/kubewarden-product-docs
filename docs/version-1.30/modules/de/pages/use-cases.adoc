include::partial$variables.adoc[]
= {project-name}-Anwendungsfälle
:revdate: 2025-11-07
:page-revdate: {revdate}
:sidebar_label: Use cases
:sidebar_position: 74
:description: A description of certain use cases for {project-name}.
:keywords: {project-name}, documentation, use cases, case studies
:doc-persona: kubewarden-all
:doc-type: explanation
:doc-topic: explanation

Dies sind einige Beispiel-Anwendungsfälle für die xref:/personas.adoc[Personas] von {project-name}.

== Fall A: Als Kubernetes-Betreiber möchte ich sicherstellen, dass mein Cluster sicher und konform ist.

Ich stelle {project-name} und seine Standardkonfiguration mit seinem `kubewarden-defaults`-Helm-Chart im `kubewarden`-Namespace bereit. Dies stellt einen Standard-PolicyServer und empfohlene ClusterAdmissionPolicies im `kubewarden`-Namespace bereit, die ausschließlich unter der Kontrolle des Kubernetes-Betreibers stehen.

Als Betreiber kann ich weitere PolicyServer unter einem verwalteten Namespace (wie `kubewarden`) hinzufügen, um die Last zu verteilen und die Fehlertoleranz zu erhöhen.

Betreiber können weitere ClusterAdmissionPolicies und ClusterAdmissionPolicyGroups bereitstellen. Diese überprüfen alle Kubernetes-Ressourcen auf jede Art von Operation (GET, CREATE, UPDATE, PATCH, DELETE, PROXY). Dies stellt sicher, dass Operationen im Cluster sicher und konform sind.

Dazu gehören:

* Sicherheit
* Compliance (gegenüber Industriestandards oder Unternehmensvorschriften)
* Ressourcenoptimierung (über mutierende Richtlinien)
* Governance von Kubernetes-Umgebungen (über Labels und Namenskonventionen)
* Best Practices
* Image-Verifizierung

Die Sicherheitserwartungen ändern sich im Laufe der Zeit. Zuvor korrekte Bereitstellungen im Cluster sind möglicherweise nicht mehr korrekt. Dennoch hat {short-project-name} diese Operationen im Cluster bereits akzeptiert. In diesen Situationen kann der Betreiber die Audit-Scanner-Funktion bereitstellen, einen CronJob, der periodisch ausgeführt wird und die vorhandenen Ressourcen im Cluster auswertet. Dies überprüft, ob der Cluster auch im Laufe der Zeit sicher und konform ist.

Der Betreiber kann Richtlinien im `monitor`-Modus anstelle des `protect`-Modus konfigurieren, um aus dem Zustand des Clusters zu lernen, ohne Operationen zu blockieren.

Betreiber können Informationen von Richtlinien und dem {short-project-name}-Stack erhalten, indem sie Protokolle und OpenTelemetry-Informationen für Metriken und Tracing konsumieren.

== Fall B: Als Kubernetes-Betreiber möchte ich meinen Kubernetes-Benutzern ein Framework zur Verfügung stellen, damit sie sich in ihren Namespaces selbst bedienen können.

Als Betreiber stelle ich {short-project-name} wie in Fall A für eine Reihe von Richtlinien meiner Wahl bereit. Dies bietet mir eine sichere Basis im Cluster, die andere Benutzer nicht umgehen können.

Sowie Fall A habe ich verschiedene Personas pro Namespace: vielleicht Teams, Teamadministratoren, Testbereitstellungen und andere. Ich erlaube jedem Namespace-Administrator, sich selbst zu bedienen, indem ich ihnen erlaube, PolicyServer in ihrem Namespace zusammen mit namespaced AdmissionPolicies und AdmissionPolicyGroups bereitzustellen. Diese Architektur bedeutet, dass sie die Kontrolle über ihren PolicyServer und ihre Richtlinien haben. Die Richtlinien gelten nur für ihren Namespace und sie beschränken die Ressourcennutzung auf ihren Namespace.

Es ermöglicht dem Betreiber auch, laute Mandanten zu trennen und leistungsstarke PolicyServer für jene Mandanten und Aufgaben zu reservieren, die beispielsweise einen hohen Durchsatz und eine geringe Latenz benötigen.

== Fall C: Als Richtlinienautor möchte ich die Werkzeuge und Sprachen verwenden, die ich kenne, um neue Richtlinien zu schreiben.

{short-project-name} erreicht dies, indem es jede Sprache unterstützt, die zu WebAssembly kompiliert, als mögliche Zielsprachen für Richtlinien. Dies bedeutet, dass Richtlinienautoren ihre Workflows (`git`, CI, Editoren, Peer-Reviews usw.) und Werkzeuge wiederverwenden können: Sprachen, Sprachbibliotheken, Test-Harnesse und Frameworks usw.

Es ermöglicht die Wiederverwendung von domänenspezifischen Sprachen (wie Rego, CEL, Kyvernos YAML+Makros) oder Allzwecksprachen (wie Go, Rust, C#, Javascript, jede, die zu Wasm kompiliert). {short-project-name} bietet xref:/tutorials/writing-policies/index.adoc[SDKs] für einige Sprachen als erstklassige Unterstützung.

{short-project-name}-Richtlinien können einfache oder komplexe xref:/explanations/context-aware-policies.adoc[kontextbezogene] Richtlinien sein. Kontextbezogene Richtlinien werden auch verwendet, um mit separaten Workloads zu interagieren (z. B. um Informationen von einem langlebigen Image-Scanner-Dienst zu erhalten).

== Fall D: Als Systemintegrator möchte ich {short-project-name} als Teil meiner Sicherheits- und Compliance-Lösung wiederverwenden.

Als Systemintegrator möchte ich {short-project-name} wiederverwenden und möglicherweise andere Lösungen wiederverwenden, indem ich sie in {short-project-name} einbeziehe.

Als Systemintegrator kann ich Teile von {short-project-name} wiederverwenden. Zum Beispiel den `policy-server`, um Ressourcen innerhalb oder außerhalb des Kubernetes-Clusters über die xref:/howtos/raw-policies.adoc["rohe Richtlinien"]-Funktion zu überwachen.

Systemintegratoren können wählen, ob sie den `kubewarden-controller` bereitstellen oder die CRDs selbst verwalten möchten. Sie können wählen, ob sie den Audit-Scanner nach Bedarf bereitstellen oder skalieren möchten.

Systemintegratoren können neue Komponenten erstellen. Zum Beispiel einen Image-Scanner und über eine kontextbezogene Richtlinie damit interagieren, ohne eine monolithische Implementierung in einem Kubernetes-Controller zu haben.

== Nicht-Ziele

{short-project-name} beabsichtigt nicht:

- Die integrierten Sicherheitsfunktionen von Kubernetes zu ersetzen, sondern sie zu ergänzen:
  - {short-project-name} bietet eine Migration von PSPs.
  - Sie können ValidatingAdmissionPolicies und CEL-Richtlinien mit der `cel-policy` von {short-project-name} wiederverwenden.
  - {short-project-name}-Richtlinien können mutierend sein, während Pod Security Admission dies nicht kann.
  - {short-project-name}-Richtlinien profitieren von den Funktionen des {short-project-name}-Stacks (Audit-Scanner, Telemetrie, CRD-Management).
- Laufzeitsicherheit wie Einbruchserkennung oder Laufzeit-Container-Isolierung bereitzustellen.
- Host-Systemschutz von Clustern bereitzustellen.
- Unendliche Flexibilität bei der Richtlinienausführung bereitzustellen. Um DoS-Angriffe zu verhindern, sind die Verarbeitungszeiten der Richtlinien begrenzt.
